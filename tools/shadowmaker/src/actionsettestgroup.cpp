// generated by Fast Light User Interface Designer (fluid) version 1.0303

#include "actionsettestgroup.hpp"
#include "mainwindow.hpp"

void ActionSetTestGroup::cb_Start_i(Fl_Button*, void*) {
  {
    StartTest();
};
}
void ActionSetTestGroup::cb_Start(Fl_Button* o, void* v) {
  ((ActionSetTestGroup*)(o->parent()))->cb_Start_i(o,v);
}

void ActionSetTestGroup::cb_Stop_i(Fl_Button*, void*) {
  {
    StopTest();
};
}
void ActionSetTestGroup::cb_Stop(Fl_Button* o, void* v) {
  ((ActionSetTestGroup*)(o->parent()))->cb_Stop_i(o,v);
}
ActionSetTestGroup::ActionSetTestGroup(int X, int Y, int W, int H, const char *L)
  : Fl_Group(0, 0, W, H, L) {
{ m_TestStatus1 = new Fl_Choice(34, 11, 198, 25, "1:");
  m_TestStatus1->down_box(FL_BORDER_BOX);
  m_TestStatus1->labelfont(4);
  m_TestStatus1->textfont(4);
} // Fl_Choice* m_TestStatus1
{ m_TestDirection1 = new Fl_Choice(35, 40, 133, 25);
  m_TestDirection1->down_box(FL_BORDER_BOX);
  m_TestDirection1->labelfont(4);
  m_TestDirection1->textfont(4);
} // Fl_Choice* m_TestDirection1
{ m_TestRoundCount1 = new Fl_Choice(182, 40, 50, 25);
  m_TestRoundCount1->down_box(FL_BORDER_BOX);
  m_TestRoundCount1->labelfont(4);
  m_TestRoundCount1->textfont(4);
} // Fl_Choice* m_TestRoundCount1
{ m_TestStatus2 = new Fl_Choice(35, 68, 198, 25, "2:");
  m_TestStatus2->down_box(FL_BORDER_BOX);
  m_TestStatus2->labelfont(4);
  m_TestStatus2->textfont(4);
} // Fl_Choice* m_TestStatus2
{ m_TestDirection2 = new Fl_Choice(35, 101, 133, 25);
  m_TestDirection2->down_box(FL_BORDER_BOX);
  m_TestDirection2->labelfont(4);
  m_TestDirection2->textfont(4);
} // Fl_Choice* m_TestDirection2
{ m_TestRoundCount2 = new Fl_Choice(183, 101, 50, 25);
  m_TestRoundCount2->down_box(FL_BORDER_BOX);
  m_TestRoundCount2->labelfont(4);
  m_TestRoundCount2->textfont(4);
} // Fl_Choice* m_TestRoundCount2
{ m_TestStatus3 = new Fl_Choice(35, 130, 198, 25, "3:");
  m_TestStatus3->down_box(FL_BORDER_BOX);
  m_TestStatus3->labelfont(4);
  m_TestStatus3->textfont(4);
} // Fl_Choice* m_TestStatus3
{ m_TestDirection3 = new Fl_Choice(35, 160, 133, 25);
  m_TestDirection3->down_box(FL_BORDER_BOX);
  m_TestDirection3->labelfont(4);
  m_TestDirection3->textfont(4);
} // Fl_Choice* m_TestDirection3
{ m_TestRoundCount3 = new Fl_Choice(183, 160, 50, 25);
  m_TestRoundCount3->down_box(FL_BORDER_BOX);
  m_TestRoundCount3->labelfont(4);
  m_TestRoundCount3->textfont(4);
} // Fl_Choice* m_TestRoundCount3
{ m_TestStatus4 = new Fl_Choice(35, 190, 198, 25, "4:");
  m_TestStatus4->down_box(FL_BORDER_BOX);
  m_TestStatus4->labelfont(4);
  m_TestStatus4->textfont(4);
} // Fl_Choice* m_TestStatus4
{ m_TestDirection4 = new Fl_Choice(35, 220, 133, 25);
  m_TestDirection4->down_box(FL_BORDER_BOX);
  m_TestDirection4->labelfont(4);
  m_TestDirection4->textfont(4);
} // Fl_Choice* m_TestDirection4
{ m_TestRoundCount4 = new Fl_Choice(183, 220, 50, 25);
  m_TestRoundCount4->down_box(FL_BORDER_BOX);
  m_TestRoundCount4->labelfont(4);
  m_TestRoundCount4->textfont(4);
} // Fl_Choice* m_TestRoundCount4
{ m_TestStatus5 = new Fl_Choice(35, 250, 198, 25, "5:");
  m_TestStatus5->down_box(FL_BORDER_BOX);
  m_TestStatus5->labelfont(4);
  m_TestStatus5->textfont(4);
} // Fl_Choice* m_TestStatus5
{ m_TestDirection5 = new Fl_Choice(35, 280, 133, 25);
  m_TestDirection5->down_box(FL_BORDER_BOX);
  m_TestDirection5->labelfont(4);
  m_TestDirection5->textfont(4);
} // Fl_Choice* m_TestDirection5
{ m_TestRoundCount5 = new Fl_Choice(183, 280, 50, 25);
  m_TestRoundCount5->down_box(FL_BORDER_BOX);
  m_TestRoundCount5->labelfont(4);
  m_TestRoundCount5->textfont(4);
} // Fl_Choice* m_TestRoundCount5
{ Fl_Button* o = new Fl_Button(32, 315, 50, 35, "Reset");
  o->labelfont(4);
} // Fl_Button* o
{ Fl_Button* o = new Fl_Button(82, 315, 50, 35, "Start");
  o->labelfont(4);
  o->callback((Fl_Callback*)cb_Start);
} // Fl_Button* o
{ Fl_Button* o = new Fl_Button(132, 315, 50, 35, "Pause");
  o->labelfont(4);
} // Fl_Button* o
{ Fl_Button* o = new Fl_Button(182, 315, 50, 35, "Stop");
  o->labelfont(4);
  o->callback((Fl_Callback*)cb_Stop);
} // Fl_Button* o
position(X, Y);
end();
}

void ActionSetTestGroup::AddValidStatus() {
  {
      m_TestStatus1->clear();
      m_TestStatus2->clear();
      m_TestStatus3->clear();
      m_TestStatus4->clear();
      m_TestStatus5->clear();
  
      m_TestDirection1->clear();
      m_TestDirection2->clear();
      m_TestDirection3->clear();
      m_TestDirection4->clear();
      m_TestDirection5->clear();
  
      m_TestRoundCount1->clear();
      m_TestRoundCount2->clear();
      m_TestRoundCount3->clear();
      m_TestRoundCount4->clear();
      m_TestRoundCount5->clear();
  
      // add status
      m_TestStatus1->add("None", 0, StatusItemCallback, (void *)((0X00000001 << 8) + (0X000000FF)), 0);
      m_TestStatus2->add("None", 0, StatusItemCallback, (void *)((0X00000002 << 8) + (0X000000FF)), 0);
      m_TestStatus3->add("None", 0, StatusItemCallback, (void *)((0X00000003 << 8) + (0X000000FF)), 0);
      m_TestStatus4->add("None", 0, StatusItemCallback, (void *)((0X00000004 << 8) + (0X000000FF)), 0);
      m_TestStatus5->add("None", 0, StatusItemCallback, (void *)((0X00000005 << 8) + (0X000000FF)), 0);
  
      extern AnimationSet g_AnimationSet;
      for(uint32_t nStatus = 0; nStatus < 100; ++nStatus){
          for(int nDirection = 0; nDirection < 8; ++nDirection){
              if(g_AnimationSet.Valid(nStatus, nDirection)){
                  extern const char *g_StatusNameList[];
                  m_TestStatus1->add(g_StatusNameList[nStatus], 0, StatusItemCallback, (void *)((0X00000001 << 8) + (nStatus & 0X000000FF)), 0);
                  m_TestStatus2->add(g_StatusNameList[nStatus], 0, StatusItemCallback, (void *)((0X00000002 << 8) + (nStatus & 0X000000FF)), 0);
                  m_TestStatus3->add(g_StatusNameList[nStatus], 0, StatusItemCallback, (void *)((0X00000003 << 8) + (nStatus & 0X000000FF)), 0);
                  m_TestStatus4->add(g_StatusNameList[nStatus], 0, StatusItemCallback, (void *)((0X00000004 << 8) + (nStatus & 0X000000FF)), 0);
                  m_TestStatus5->add(g_StatusNameList[nStatus], 0, StatusItemCallback, (void *)((0X00000005 << 8) + (nStatus & 0X000000FF)), 0);
                  break;
              }
          }
      }
      m_TestStatus1->value(0);
      m_TestStatus2->value(0);
      m_TestStatus3->value(0);
      m_TestStatus4->value(0);
      m_TestStatus5->value(0);
  
      // add direction
      m_TestDirection1->add("None", 0, 0, (void *)(0), 0);
      m_TestDirection2->add("None", 0, 0, (void *)(0), 0);
      m_TestDirection3->add("None", 0, 0, (void *)(0), 0);
      m_TestDirection4->add("None", 0, 0, (void *)(0), 0);
      m_TestDirection5->add("None", 0, 0, (void *)(0), 0);
  
      m_TestDirection1->value(0);
      m_TestDirection2->value(0);
      m_TestDirection3->value(0);
      m_TestDirection4->value(0);
      m_TestDirection5->value(0);
  
      // add round count
      
      m_TestRoundCount1->add("0", 0, 0, (void *)(0), 0);
      m_TestRoundCount2->add("0", 0, 0, (void *)(0), 0);
      m_TestRoundCount3->add("0", 0, 0, (void *)(0), 0);
      m_TestRoundCount4->add("0", 0, 0, (void *)(0), 0);
      m_TestRoundCount5->add("0", 0, 0, (void *)(0), 0);
  
      m_TestRoundCount1->value(0);
      m_TestRoundCount2->value(0);
      m_TestRoundCount3->value(0);
      m_TestRoundCount4->value(0);
      m_TestRoundCount5->value(0);
      
  }
}

void ActionSetTestGroup::StatusItemCallback(Fl_Widget * pWidget, void *pData) {
  {
      auto pRoot = (ActionSetTestGroup *)(pWidget->parent());
      auto nArg  = (uint32_t)pData;
      pRoot->AddValidDirection((0X0000FF00 & nArg) >> 8, 0X000000FF & nArg);
  }
}

void ActionSetTestGroup::AddValidDirection(int nIndex, int nStatus) {
  {
      // printf("%d %d\n", nIndex, nStatus);
      Fl_Choice *stDirectionChoiceArr[] = {
          m_TestDirection1,
          m_TestDirection2,
          m_TestDirection3,
          m_TestDirection4,
          m_TestDirection5
      };
  
      Fl_Choice *stRoundCountChoiceArr[] = {
          m_TestRoundCount1,
          m_TestRoundCount2,
          m_TestRoundCount3,
          m_TestRoundCount4,
          m_TestRoundCount5
      };
  
      stDirectionChoiceArr [nIndex - 1]->clear();
      stRoundCountChoiceArr[nIndex - 1]->clear();
      if(nStatus < 100){
          // at least there is one direction available for this status
          // otherwise this function can't be invoked
          extern AnimationSet g_AnimationSet;
          for(int nDirection = 0; nDirection < 8; ++nDirection){
              if(g_AnimationSet.Valid(nStatus, nDirection)){
                  stDirectionChoiceArr[nIndex - 1]->add(
                          (std::string("Direction ") + std::to_string(nDirection)).c_str(), 0, 0, 
                          (void *)nDirection, 0);
              }
          }
      }
  
      if(stDirectionChoiceArr[nIndex - 1]->size() == 0){
          stDirectionChoiceArr [nIndex - 1]->add("None", 0, 0, 0, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "0", 0, 0, 0, 0);
      }else{
          stRoundCountChoiceArr[nIndex - 1]->add(   "1", 0, 0, (void *)1, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "2", 0, 0, (void *)2, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "3", 0, 0, (void *)3, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "4", 0, 0, (void *)4, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "5", 0, 0, (void *)5, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "6", 0, 0, (void *)6, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "7", 0, 0, (void *)7, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "8", 0, 0, (void *)8, 0);
          stRoundCountChoiceArr[nIndex - 1]->add(   "9", 0, 0, (void *)9, 0);
      }
      stRoundCountChoiceArr[nIndex - 1]->value(0);
      stRoundCountChoiceArr[nIndex - 1]->textfont(4);
      stDirectionChoiceArr [nIndex - 1]->value(0);
      stDirectionChoiceArr [nIndex - 1]->textfont(4);
  }
}

uint32_t ActionSetTestGroup::GetTestActionSetCode(int nIndex) {
  {
      Fl_Choice *stStatusChoiceArr[] = {
          m_TestStatus1,
          m_TestStatus2,
          m_TestStatus3,
          m_TestStatus4,
          m_TestStatus5,
      };
  
      Fl_Choice *stDirectionChoiceArr[] = {
          m_TestDirection1,
          m_TestDirection2,
          m_TestDirection3,
          m_TestDirection4,
          m_TestDirection5
      };
  
      Fl_Choice *stRoundCountChoiceArr[] = {
          m_TestRoundCount1,
          m_TestRoundCount2,
          m_TestRoundCount3,
          m_TestRoundCount4,
          m_TestRoundCount5
      };
  
      uint32_t nStatus     = 0;
      uint32_t nDirection  = 0;
      uint32_t nRoundCount = 0;
  
      // nIndex = 1, 2, 3, 4, 5
      
      { // status
          auto pStatusMenu = stStatusChoiceArr[nIndex - 1]->menu();
          auto nSelected   = stStatusChoiceArr[nIndex - 1]->value();
          nStatus = (uint32_t)(pStatusMenu[nSelected].user_data());
      }
  
      { // direction
          auto pDirectionMenu = stDirectionChoiceArr[nIndex - 1]->menu();
          auto nSelected      = stDirectionChoiceArr[nIndex - 1]->value();
          nDirection = (uint32_t)(pDirectionMenu[nSelected].user_data());
      }
  
      { // round count
          auto pRoundCountMenu = stRoundCountChoiceArr[nIndex - 1]->menu();
          auto nSelected       = stRoundCountChoiceArr[nIndex - 1]->value();
          nRoundCount = (uint32_t)(pRoundCountMenu[nSelected].user_data());
      }
  
      return 0
          + ((((uint32_t)nIndex     ) & 0X000000FF) << 24)
          + ((((uint32_t)nStatus    ) & 0X000000FF) << 16)
          + ((((uint32_t)nDirection ) & 0X000000FF) <<  8)
          + ((((uint32_t)nRoundCount) & 0X000000FF) <<  0)
          ;
  }
}

void ActionSetTestGroup::StartTest() {
  {
      extern uint32_t    g_TestAnimationCode;
      extern MainWindow *g_MainWindow;
      g_MainWindow->EnableAnimation(true);
      
      for(int nIndex = 1; nIndex <= 5; ++nIndex){
          g_TestAnimationCode = GetTestActionSetCode(nIndex);
          uint32_t nStatus    = ((g_TestAnimationCode & 0X00FF0000) >> 16);
          uint32_t nDirection = ((g_TestAnimationCode & 0X0000FF00) >>  8);
          if(nStatus < 100){
              extern AnimationSet g_AnimationSet;
              g_AnimationSet.SetStatus(nStatus);
              g_AnimationSet.SetDirection(nDirection);
              return;
          }
      }
      g_TestAnimationCode = 0X00FFFFFF;
  }
}

void ActionSetTestGroup::StopTest() {
  {
      extern uint32_t    g_TestAnimationCode;
      extern MainWindow *g_MainWindow;
      g_MainWindow->EnableAnimation(false);
      g_TestAnimationCode &= 0X00FFFFFF;
  }
}
